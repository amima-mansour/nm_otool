A Mach-O file contains three major regions :
1- Header structure that identifies the file as a Mach-O
executable file. The header also contains other basic file type information, indicates the target
CPU architecture, and contains flags specifying options that affect the interpretation of the rest
of the file.
2- Directly following the header are a series of variable-size load commands that specify the layout
and linkage characteristics of the Mach-O file. Among other information, the load commands can
specify:
* The initial layout of the file in virtual memory
* The location of the symbol table (used for both dynamic linking and debugging information)
* The initial execution state of the main thread of the program
* The names of shared libraries that contain definitions for the main executable’s imported
symbols
3- Following the load commands, all Mach-O files contain the data of one or more segments. Each
segment contains zero or more sections. Each section of a segment contains code or data of some
particular type. Each segment defines a region of virtual memory that the dynamic linker maps
into the address space of the process. The exact number and layout of segments and sections is
specified by the load commands and the file type.

ranlib :
struct ranlib
{
 union
 {
 unsigned long ran_strx;
 char * ran_name;
 } ran_un;
 unsigned long ran_off;
};
ran_strx : The index number (zero-based) of the string in the string table that follows the array of ranlib
data structures
ran_name : The byte offset, from the start of the file, at which the symbol name can be found.
ran_off : The byte offset, from the start of the file, at which the header line for the member containing
this symbol can be found.

=> A static archive library begins with the file identifier string !<arch>, followed by a newline character
The file identifier string is followed by a series of member files.  Each member
consists of a fixed-length header line followed by the file data. The header line is 60 bytes long and
is divided into five fixed-length fields, as shown in this example header line:
grapple.c 999514211 501 20 100644 167 `\n
All header fields are defined in ASCII and padded with spaces to the full length of the field.
All fields are defined in decimal notation, except for the file mode field, which is defined in octal.
These are the descriptions for each field:
1- The name field (16 bytes) contains the name of the file. If the name is either longer than 16 bytes
or contains a space character, the actual name should be written directly after the header line and
the name field should contain the string #1/ followed by the length. To keep the archive entries
aligned to 4 byte boundaries, the length of the name that follows the #1/ is rounded to 4 bytes
and the name that follows the header is padded with null bytes.
2- The modified date field (12 bytes) is taken from the st_time field returned by the stat system
call.
3- The user ID field (6 bytes) is taken from the st_uid field returned by the stat system call.
4- The group ID field (6 bytes) is taken from the st_gid field returned by the stat system call.
5- The file mode field (8 bytes) is taken from the st_mode field returned by the stat system call.
This field is written in octal notation.
6- The file size field (8 bytes) is taken from the st_size field returned by the stat system call.
The first member in a static archive library is always the symbol table describing the contents of the
rest of the member files. This member is always called either __.SYMDEF or __.SYMDEF SORTED (note
the two leading underscores and the period). The name used depends on the sort order of the symbol
table. The older variant—__.SYMDEF—contains entries in the same order that they appear in the object
files. The newer variant—__.SYMDEF SORTED— contains entries in alphabetical order, which allows
the static linker to load the symbols faster.
The __.SYMDEF and .__SORTED SYMDEF archive members contain an array of ranlib data structures
preceded by the length in bytes (a long integer, 4 bytes) of the number of items in the array. The array
is followed by a string table of null-terminated strings, which are preceded by the length in bytes of
the entire string table (again, a 4-byte long integer).
The string table is an array of C strings, each terminated by a null byte.
The ranlib declarations can be found in /usr/include/mach-o/ranlib.h


void	handle_fat_32(t_file *file)
{
	struct fat_header   *hd;
    uint32_t            num;
    struct fat_arch     *archs;
    uint32_t            i;

	hd = (struct fat_header *)(file->ptr + file->off);
	archs = (struct fat_arch *)(hd + 1);
	num = swap32(file->swap_bits, hd->nfat_arch);
	i = 0;
	while (i < num)
    {
		ft_printf("%u\n", i);
        const char *name = "unknown";
        switch(swap32(file->swap_bits, archs[i].cputype))
        {
            case CPU_TYPE_I386:     name = "i386";      break;
            case CPU_TYPE_X86_64:   name = "x86_64";    break;
            case CPU_TYPE_ARM:      name = "arm";       break;
            case CPU_TYPE_ARM64:    name = "arm64";     break;
        }
        uint32_t off = swap32(file->swap_bits, archs[i].offset);
        uint32_t magic = *(uint32_t*)((uintptr_t)(file->ptr + off));
		printf("%08x-%08x: %-8s (magic %8x)\n", off, off + swap32(file->swap_bits, archs[i].size), name, magic);
        // check for known magic
		if (magic == MH_CIGAM_64 || magic == MH_MAGIC_64)
			file->off = swap32(file, archs[i].offset);
		else if (!(file->off) && (magic == MH_CIGAM || \
			magic == MH_MAGIC))
			file->off = swap32(file, archs[i].offset);
		//file->off = off;
		//nm(file);
		//file->content = *(uint32_t*)((uintptr_t)(file->content + swap32(file->swap_bits, archs[i].size)));
		i++;
	}
	nm(file);
}


void							*safe(const uint64_t offset, const size_t size)
{
	if (offset + size < offset)
		return (NULL);
	return ((void *) \
		((size_t)(safe_pointer.ptr + safe_pointer.start_offset + offset) * \
		(safe_pointer.start_offset + offset + size <= safe_pointer.filesize)));
}

COMMANDE TO test arch :
lipo -detailed_info file